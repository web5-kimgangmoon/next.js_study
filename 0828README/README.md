## 08/28

### 정적렌더링

사용자가 귀하의 애플리케이션을 방문할 때마다 캐시된 결과가 제공됩니다. 정적 렌더링에는 몇 가지 이점이 있습니다.

1. 더 빠른 웹사이트 - 사전 렌더링된 콘텐츠는 캐시되어 전 세계적으로 배포될 수 있습니다. 이를 통해 전 세계 사용자가 귀하의 웹사이트 콘텐츠에 더 빠르고 안정적으로 액세스할 수 있습니다.

2. 서버 부하 감소 - 콘텐츠가 캐시되므로 서버는 사용자 요청에 따라 콘텐츠를 동적으로 생성할 필요가 없습니다.

3. SEO - 사전 렌더링된 콘텐츠는 검색 엔진 크롤러가 색인하기 더 쉽습니다. 페이지가 로드될 때 콘텐츠가 이미 사용 가능하기 때문입니다. 이는 검색 엔진 순위를 개선하는 데 도움이 될 수 있습니다.

정적 렌더링은 데이터가 없거나 사용자 간에 공유되는 데이터 (예: 정적 블로그 게시물 또는 제품 페이지) 가 있는 UI에 유용합니다 . 정기적으로 업데이트되는 개인화된 데이터가 있는 대시보드에는 적합하지 않을 수 있습니다.

정적 렌더링의 반대는 동적 렌더링입니다.

### 동적렌더링

동적 렌더링을 사용하면 요청 시간 (사용자가 페이지를 방문할 때) 에 각 사용자에 대한 콘텐츠가 서버에서 렌더링됩니다 . 동적 렌더링에는 몇 가지 이점이 있습니다.

1. 실시간 데이터 - 동적 렌더링을 통해 애플리케이션에서 실시간 또는 자주 업데이트되는 데이터를 표시할 수 있습니다. 이는 데이터가 자주 변경되는 애플리케이션에 이상적입니다.

2. 사용자별 콘텐츠 - 대시보드나 사용자 프로필과 같은 개인화된 콘텐츠를 제공하고 사용자 상호 작용에 따라 데이터를 업데이트하는 것이 더 쉽습니다.

3. 요청 시간 정보 - 동적 렌더링을 사용하면 쿠키나 URL 검색 매개변수와 같이 요청 시점에서만 알 수 있는 정보에 액세스할 수 있습니다.

#### 동적 렌더링을 사용하면 애플리케이션의 속도는 가장 느린 데이터 가져오기 속도에 따라 결정됩니다.

### 스트리밍이란?

스트리밍은 경로를 더 작은 "조각"으로 나누고 데이터가 준비되면 서버에서 클라이언트로 점진적으로 스트리밍할 수 있는 데이터 전송 기술입니다.

### route groups

경로 그룹을 사용하면 URL 경로 구조에 영향을 주지 않고 파일을 논리적 그룹으로 구성할 수 있습니다. 괄호를 사용하여 새 폴더를 만들면 ()이름이 URL 경로에 포함되지 않습니다.

## streaming a component

지금까지는 전체 페이지를 스트리밍하고 있습니다. 하지만 React Suspense를 사용하면 더 세부적으로 특정 구성 요소를 스트리밍할 수도 있습니다.

Suspense를 사용하면 일부 조건이 충족될 때까지(예: 데이터가 로드됨) 애플리케이션의 렌더링 부분을 연기할 수 있습니다. Suspense에서 동적 구성 요소를 래핑할 수 있습니다. 그런 다음 동적 구성 요소가 로드되는 동안 표시할 대체 구성 요소를 전달합니다.

느린 데이터 요청을 기억한다면 fetchRevenue(), 이 요청은 전체 페이지를 느리게 만듭니다. 전체 페이지를 차단하는 대신 Suspense를 사용하여 이 구성 요소만 스트리밍하고 나머지 페이지 UI를 즉시 표시할 수 있습니다.

### Supspense

Suspense에서 구성 요소를 래핑해야 합니다 . 각 개별 카드에 대한 데이터를 가져올 수 있지만, 카드가 로드될 때 팝핑 효과가 발생할 수 있으며 , 이는 사용자에게 시각적으로 어색할 수 있습니다.

더 많은 계단식 효과를 만들려면 래퍼 구성 요소를 사용하여 카드를 그룹화할 수 있습니다. 즉, 정적 렌더링이 먼저 표시되고 그 다음에 카드가 표시됩니다.

서스펜스 경계를 ​​어디에 두는지는 몇 가지 사항에 따라 달라집니다.

페이지가 스트리밍될 때 사용자가 페이지를 어떻게 경험하길 원하는지입니다.
어떤 콘텐츠를 우선시하고 싶은가.
구성 요소가 데이터 가져오기에 의존하는 경우.
대시보드 페이지를 살펴보세요. 다르게 했다면 좋았을 것이 있나요?

걱정하지 마세요. 정답은 없습니다.

1. 전체 페이지를 스트리밍할 수 있지만 loading.tsx, 구성 요소 중 하나의 데이터 가져오기 속도가 느리면 로딩 시간이 길어질 수 있습니다.

2. 각 구성 요소를 개별적으로 스트리밍할 수 있지만 , 그러면 UI가 준비되면서 화면에 팝업 으로 표시될 수 있습니다.

3. 페이지 섹션을 스트리밍하여 계단식 효과를 만들 수도 있습니다 . 하지만 래퍼 구성 요소를 만들어야 합니다.

서스펜스 경계를 ​​두는 위치는 애플리케이션에 따라 다릅니다. 일반적으로 데이터 페치를 필요한 구성 요소로 옮긴 다음 해당 구성 요소를 Suspense로 래핑하는 것이 좋습니다. 하지만 애플리케이션에 필요한 것이라면 섹션이나 전체 페이지를 스트리밍하는 데 아무런 문제가 없습니다.

Suspense를 사용해 보고 어떤 것이 가장 효과적인지 확인하는 것을 두려워하지 마세요. Suspense는 더욱 즐거운 사용자 경험을 만드는 데 도움이 되는 강력한 API입니다.

### Partial Prerendering (PPR)

(부분 사전 렌더링)

Next.js 14는 Partial Prerendering 의 실험적 버전을 도입했습니다 . 이는 동일한 경로에서 정적 및 동적 렌더링의 이점을 결합할 수 있는 새로운 렌더링 모델입니다.

사용자가 경로를 방문할 때:

1. 탐색 바와 제품 정보를 포함하는 정적 경로 셸이 제공되어 초기 로드 속도가 빨라집니다.

2. 셸은 장바구니나 추천 상품과 같은 동적 콘텐츠가 비동기적으로 로드되는 곳에 구멍을 남깁니다.

3. async hole은 병렬로 스트리밍되어 페이지 전체 로드 시간이 줄어듭니다.

부분 사전 렌더링은 React의 Suspense를 사용합니다.(이전 장에서 배웠던) 특정 조건이 충족될 때까지(예: 데이터가 로드될 때까지) 애플리케이션의 일부 렌더링을 연기합니다.

Suspense 폴백은 정적 콘텐츠와 함께 초기 HTML 파일에 내장됩니다. 빌드 시(또는 재검증 시) 정적 콘텐츠는 정적 셸을 생성하기 위해 사전 렌더링 됩니다 . 동적 콘텐츠의 렌더링은 사용자가 경로를 요청할 때까지 연기 됩니다.

Suspense로 컴포넌트를 래핑해도 컴포넌트 자체가 동적으로 바뀌지는 않지만, Suspense는 정적 코드와 동적 코드 간의 경계로 사용됩니다.

대시보드 경로에 PPR을 구현하는 방법을 살펴보겠습니다.

그게 전부입니다. 개발 단계에서는 애플리케이션에서 차이를 볼 수 없을지 몰라도 프로덕션 단계에서는 성능 향상을 느낄 수 있을 것입니다. Next.js는 경로의 정적 부분을 미리 렌더링하고 사용자가 요청할 때까지 동적 부분을 연기합니다.

next.config.mjs

```js
const nextConfig = {
  experimental: {
    ppr: "incremental",
  },
};

export default nextConfig;
```

/app/dashboard/layout.tsx

```tsx
export const experimental_ppr = true;
```

부분 사전 렌더링의 장점은 사용하기 위해 코드를 변경할 필요가 없다는 것입니다. Suspense를 사용하여 경로의 동적 부분을 래핑하는 한 Next.js는 경로의 어떤 부분이 정적이고 어떤 부분이 동적인지 알 수 있습니다.

#### 요약하자면, 애플리케이션에서 데이터 가져오기를 최적화하기 위해 몇 가지 작업을 수행했습니다.

1. 서버와 데이터베이스 간의 지연 시간을 줄이기 위해 애플리케이션 코드와 동일한 지역에 데이터베이스를 생성했습니다.

2. React Server Components를 사용하여 서버에서 데이터를 페치합니다. 이를 통해 값비싼 데이터 페치와 로직을 서버에 보관하고, 클라이언트 측 JavaScript 번들을 줄이고, 데이터베이스 비밀이 클라이언트에 노출되는 것을 방지할 수 있습니다.

3. SQL을 사용하여 필요한 데이터만 가져오고, 각 요청에 대해 전송되는 데이터 양과 메모리 내에서 데이터를 변환하는 데 필요한 JavaScript 양을 줄였습니다.

4. JavaScript를 사용하여 데이터 가져오기를 병렬화합니다(필요한 경우).

5. 느린 데이터 요청으로 인해 전체 페이지가 막히는 것을 방지하기 위해 스트리밍을 구현했으며, 사용자는 모든 것이 로드될 때까지 기다리지 않고도 UI와 상호 작용을 시작할 수 있습니다.

6. 데이터 가져오기를 필요한 구성 요소로 옮겨서 경로의 어떤 부분을 동적으로 처리해야 하는지 분리합니다.

### URL 검색 매개변수를 사용하는 이유

URL 검색 매개변수를 사용하여 검색 상태를 관리하게 됩니다. 이 패턴은 클라이언트 측 상태에서 사용하는 데 익숙하다면 새로운 것일 수 있습니다.

URL 매개변수로 검색을 구현하는 데는 몇 가지 이점이 있습니다.

1. 북마크 및 공유 가능 URL : 검색 매개변수가 URL에 있으므로 사용자는 검색 쿼리 및 필터를 포함하여 애플리케이션의 현재 상태를 북마크하여 향후 참조 또는 공유할 수 있습니다.

2. 서버 측 렌더링 및 초기 로드 : URL 매개변수는 서버에서 직접 사용되어 초기 상태를 렌더링할 수 있으므로 서버 렌더링을 처리하기가 더 쉽습니다.

3. 분석 및 추적 : URL에 검색어와 필터를 직접 추가하면 추가적인 클라이언트 측 로직이 필요 없이 사용자 행동을 쉽게 추적할 수 있습니다.

#### 사족: 정적렌더링처럼 쓸 수 있는 동적렌더링을 구현할 수 있다는 것이 아닐까 추측된다.

검색 기능을 구현하는 데 사용할 Next.js 클라이언트 후크는 다음과 같습니다.

1. useSearchParams- 현재 URL의 매개변수에 액세스할 수 있습니다. 예를 들어, 이 URL의 검색 매개변수는 /dashboard/invoices?page=1&query=pending다음과 같습니다 {page: '1', query: 'pending'}.

2. usePathname- 현재 URL의 경로 이름을 읽을 수 있습니다. 예를 들어, 경로의 경우 /dashboard/invoices. usePathname을 반환합니다.

3. useRouter- 클라이언트 구성 요소 내에서 경로 간 탐색을 프로그래밍 방식으로 활성화합니다. 사용할 수 있는 여러 가지 방법이 있습니다 .

### 디바운싱

디바운싱은 함수가 실행될 수 있는 속도를 제한하는 프로그래밍 관행입니다. 우리의 경우, 사용자가 타이핑을 멈췄을 때만 데이터베이스를 쿼리하고 싶습니다.

디바운싱 작동 방식:

1. 트리거 이벤트 : 디바운스되어야 하는 이벤트(예: 검색 상자의 키 입력)가 발생하면 타이머가 시작됩니다.
2. 대기 : 타이머가 만료되기 전에 새로운 이벤트가 발생하면 타이머가 재설정됩니다.
3. 실행 : 타이머가 카운트다운 끝에 도달하면, 디바운스된 함수가 실행됩니다.

디바운싱은 여러 가지 방법으로 구현할 수 있으며, 여기에는 직접 디바운스 함수를 만드는 것도 포함됩니다. 간단하게 하기 위해 라이브러리를 사용하겠습니다.

```bash
pnpm i use-debounce
```

디바운싱을 통해 데이터베이스로 전송되는 요청 수를 줄여 리소스를 절약할 수 있습니다.

### 서버액션

Next.js는 렌더링 작업과 데이터 요청을 캐싱하여 애플리케이션의 성능을 개선하고 비용을 절감합니다.

```ts
"use server";
```

추가하면 파일 내의 모든 내보낸 함수를 서버 작업으로 표시합니다. 그런 다음 이러한 서버 함수를 가져와 클라이언트 및 서버 구성 요소에서 사용할 수 있습니다.
또한 액션 내부에 추가하여 Server Components 내부에 Server Actions를 직접 작성할 수도 있습니다

#### 추가설명

알아두면 좋은 정보 : HTML에서는 속성에 URL을 전달합니다 action. 이 URL은 양식 데이터를 제출해야 하는 대상(일반적으로 API 엔드포인트)이 됩니다.

그러나 React에서는 이 action속성이 특별한 prop으로 간주됩니다. 즉, React는 이 속성을 기반으로 작업을 호출할 수 있도록 합니다.

백그라운드에서 서버 액션은 POSTAPI 엔드포인트를 생성합니다. 이것이 서버 액션을 사용할 때 API 엔드포인트를 수동으로 생성할 필요가 없는 이유입니다.

#### 여러개의 데이터를 넣을 경우의 팁

필드가 많은 양식으로 작업하는 경우 다음을 사용하는 것이 좋습니다. entries()JavaScript를 사용한 방법 Object.fromEntries()

### 유형 검증 및 강제 변환

양식의 데이터가 데이터베이스의 예상 유형과 일치하는지 확인하는 것이 중요합니다. 예를 들어, console.log액션 내부에 다음을 추가하는 경우:

유형 검증을 처리하려면 몇 가지 옵션이 있습니다. 수동으로 유형을 검증할 수 있지만 유형 검증 라이브러리를 사용하면 시간과 노력을 절약할 수 있습니다. 예를 들어 Zod를 사용하겠습니다. 이 작업을 간소화해 주는 TypeScript 우선 검증 라이브러리입니다.

### 재검증 및 리디렉션

Next.js에는 경로 세그먼트를 일정 시간 동안 사용자 브라우저에 저장하는 클라이언트 측 라우터 캐시가 있습니다. 이 캐시는 사전 페칭 과 함께 사용자가 서버에 대한 요청 수를 줄이는 동시에 경로 간을 빠르게 탐색할 수 있도록 합니다.

송장 경로에 표시된 데이터를 업데이트하고 있으므로 이 캐시를 지우고 서버에 대한 새 요청을 트리거하려고 합니다. revalidatePathNext.js의 함수를 사용하여 이를 수행할 수 있습니다.

### 동적 경로 만들기

Next.js를 사용 하면 정확한 세그먼트 이름을 모르고 데이터를 기반으로 경로를 만들고 싶을 때 동적 경로 세그먼트를[id] 만들 수 있습니다. 이는 블로그 게시물 제목, 제품 페이지 등일 수 있습니다. 폴더 이름을 대괄호로 묶어 동적 경로 세그먼트를 만들 수 있습니다. 예를 들어, , [post]또는 [slug].

폴더 에서 /invoices라는 새 동적 경로를 만든 다음 , 파일 로 [id]라는 새 경로를 만듭니다 . 파일 구조는 다음과 같아야 합니다.

### UUID VS Auto-incrementing Keys

우리는 키(예: 1, 2, 3 등)를 증가시키는 대신 UUID를 사용합니다. 이렇게 하면 URL이 길어지지만 UUID는 ID 충돌 위험을 제거하고 전역적으로 고유하며 열거형 공격 위험을 줄여 대규모 데이터베이스에 이상적입니다.

하지만 더 깔끔한 URL을 선호하는 경우 자동 증가 키를 사용하는 것이 좋습니다.

마지막으로, 데이터베이스에서 올바른 레코드를 업데이트할 수 있도록 Server Action에 를 전달하려고 합니다. 인수로 전달할 수는 없습니다.

redirect블록 밖에서 호출되는 방법에 주목하세요 try/catch. 이는 redirect오류를 발생시켜 작동하기 때문에 블록에서 잡힙니다 catch. 이를 방지하려면 . redirect 이후에 호출 하면 성공한 경우에만 도달할 수 있습니다

### 에러 처리

error.tsx 파일

1. "use client" - error.tsx클라이언트 구성 요소여야 합니다. 두 개의 소품을 받아들입니다.

2. error: 이 객체는 JavaScript의 기본 인스턴스입니다.

3. reset: 오류 경계를 재설정하는 기능입니다. 실행하면 이 기능은 경로 세그먼트를 다시 렌더링하려고 시도합니다.

not-found.tsx 파일

1. error.tsx보다 우선시하므로 구체적인 오류를 처리할 때 이용할 수 있다.

14장 계속
