## 08/27

글꼴을 사용하면 브라우저가 처음에 대체 또는 시스템 글꼴로 텍스트를 렌더링한 다음 로드된 후 사용자 지정 글꼴로 교체할 때 레이아웃 이동이 발생합니다. 이 교체로 인해 텍스트 크기, 간격 또는 레이아웃이 변경되어 주변 요소가 이동할 수 있습니다.

Next.js 모듈을 사용할 때 응용 프로그램의 글꼴을 자동으로 최적화합니다. 빌드 시간에 글꼴 파일을 다운로드하고 다른 정적 자산과 함께 호스팅합니다. 즉, 사용자가 애플리케이션을 방문할 때 성능에 영향을 줄 수 있는 글꼴에 대한 추가 네트워크 요청이 없습니다.

이미지 최적화는 그 자체로 전문화로 간주될 수 있는 웹 개발의 큰 주제입니다. 이러한 최적화를 수동으로 구현하는 대신 구성 요소를 사용하여 이미지를 자동으로 최적화할 수 있습니다.

1. 이미지가 로드될 때 레이아웃이 자동으로 이동하는 것을 방지합니다.
2. 뷰포트가 더 작은 장치로 큰 이미지를 배송하지 않도록 이미지 크기를 조정합니다.
3. 기본적으로 이미지를 지연 로드합니다(이미지가 뷰포트에 들어갈 때 로드됨).
4. 최신 형식으로 이미지 제공

#### 간단하게 말해 next에서는 자동으로 이미지 최적화를 지원하며, 이 기능은 public 폴더 안에 이미지를 넣음으로써 이용할 수 있다.

중첩 라우팅
Next.js는 폴더가 중첩된 경로를 만드는 데 사용되는 파일 시스템 라우팅을 사용합니다. 각 폴더는 URL 세그먼트에 매핑되는 경로 세그먼트를 나타냅니다

page.tsx 는 React 구성 요소를 내보내는 특수 Next.js 파일이며 경로에 액세스할 수 있어야 합니다. 응용 프로그램에는 이미 페이지 파일이 있습니다. - 이것은 경로와 연결된 홈 페이지입니다

#### nextjs에서는 폴더를 만들고 그 안에 page.tsx를 만듬으로써 자동으로 경로를 분배해 줄 수 있다. 거기다가 폴더 안에 폴더를 만듬으로써 중첩 라우팅이 가능하다.

Next.js에서 레이아웃을 사용하는 한 가지 이점은 탐색 시 페이지 구성 요소만 업데이트되고 레이아웃은 다시 렌더링되지 않는다는 것입니다. 이를 부분 렌더링이라고 합니다.

#### 본래 react는 고의적으로 path를 나누고 부분렌더링을 구현해줘야 했지만, layout.tsx 파일을 이용하면 굳이 그런 수고를 들이지 않고도 구현이 가능하다.

#### 루트 레이아웃은 모든 페이지에서 공유되며, 루트 레이아웃의 children 요소 안에 페이지가 들어간다.

서버 구성 요소를 사용하여 데이터 가져오기
기본적으로 Next.js 애플리케이션은 React 서버 구성 요소를 사용합니다. 서버 구성 요소를 사용하여 데이터를 가져오는 것은 비교적 새로운 접근 방식이며 이를 사용하면 몇 가지 이점이 있습니다.

서버 구성 요소는 데이터 가져오기와 같은 비동기 작업을 위한 더 간단한 솔루션을 제공하는 약속을 지원합니다. 데이터를 가져오는 라이브러리를 없이 구문을 사용할 수 있습니다.async/awaituseEffectuseState
서버 구성 요소는 서버에서 실행되므로 비용이 많이 드는 데이터 가져오기 및 로직을 서버에 보관하고 결과만 클라이언트로 보낼 수 있습니다.
앞서 언급했듯이 서버 구성 요소는 서버에서 실행되므로 추가 API 계층 없이 데이터베이스를 직접 쿼리할 수 있습니다.

#### nextjs는 async 함수로 된 컴포넌트로 구성할 수 있다.

그렇지만... 다음 두 가지 사항에 유의해야 합니다.

1. 데이터 요청이 의도치 않게 서로를 차단하여 요청 폭포를 생성합니다.
2. 기본적으로 성능 향상을 위해 경로를 사전 렌더링Next.js 이를 정적 렌더링이라고 합니다. 따라서 데이터가 변경되어도 대시보드에 반영되지 않습니다.

이 장에서 1번에 대해 논의한 후 다음 장에서 2번에 대해 자세히 살펴보겠습니다.

"폭포수"는 이전 요청의 완료에 의존하는 일련의 네트워크 요청을 나타냅니다. 데이터 가져오기의 경우 각 요청은 이전 요청에서 데이터를 반환한 후에만 시작할 수 있습니다.
예를 들어, 실행을 시작하기 전에 실행을 기다려야 합니다.

이 패턴이 반드시 나쁜 것은 아닙니다. 폭포를 원하는 경우가있을 수 있습니다 다음 요청을 하기 전에 조건이 충족되기를 원하기 때문입니다. 때문에 예를 들어 사용자의 ID와 프로필 정보를 먼저 가져올 수 있습니다. 한번 ID가 있으면 친구 목록을 가져올 수 있습니다. 이 경우 각 요청은 이전 요청에서 반환된 데이터에 따라 달라집니다.

그러나 이 동작은 의도하지 않은 것일 수도 있으며 성능에 영향을 줄 수 있습니다.

폭포를 피하는 일반적인 방법은 모든 데이터 요청을 동시에 병렬로 시작하는 것입니다.

JavaScript에서는 Promise.all() 또는 Promise.allSettled() 모든 약속을 동시에 시작하는 기능. 예를 들어, in , 우리는 함수에서 사용하고 있습니다.

이 패턴을 사용하여 다음을 수행할 수 있습니다.

1. 모든 데이터 가져오기를 동시에 실행하기 시작하면 성능이 향상될 수 있습니다.
2. 모든 라이브러리 또는 프레임워크에 적용할 수 있는 기본 JavaScript 패턴을 사용합니다.

그러나 이 JavaScript 패턴에만 의존하는 것에는 한 가지 단점이 있습니다: 한 데이터 요청이 다른 모든 데이터 요청보다 느리면 어떻게 될까요?
